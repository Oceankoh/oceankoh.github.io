My Drive
Criterion C
------

#### Techniques used
1. , Programming Language
    * Maze generation algorithm
    * Scoring algorithm
    * Data Parsing
    * Player Navigation
2. Flutter SDK
    * Creation of GUI Components
    * Handling User interaction with GUI elements
    * Local Storage of User Data
    * Handling user input
    * Animations
    * Game Audio
    * Managing application lifecycle
3. Firebase
    * Asynchronous Network Communications with Database
    * NoSQL database storage system
4. Android Studio
    * Emulation of application
    * Writing of code, and debugging application

---

#### Dart Programming Language
1. Randomized Maze Generation Algorithm

   * Representation of single maze block. 

Each Maze block has multiple booleans, one for each of the 4 walls (`_up`, `_down`, `_left`, `_right`). If the boolean is true, the wall exists and should be rendered. `_icon` represents whether the player icon should be rendered at that cell. `_visited` is used for the DFS algorithm explained later. 

```dart  
//Represents each square/block in the grid maze with all configurable parameters
class Block {
  //private booleans up/down/left/right to represent whether the wall exists
  bool _up = true;
  bool _right = true;
  bool _down = true;
  bool _left = true;
  //true if player is at the current block
  bool _icon = false;
  //Represent visited status during maze generation
  bool _visited = false;

  //getter and setter methods for the private variables above
  bool getUp() => _up;

  set up(bool value) {
    _up = value;
  }

  bool getRight() => _right;

  set right(bool value) {
    _right = value;
  }

  bool getDown() => _down;

  set down(bool value) {
    _down = value;
  }

  bool getLeft() => _left;

  set left(bool value) {
    _left = value;
  }

  bool getIcon() => _icon;

  set icon(bool value) {
    _icon = value;
  }

  bool getVisited() => _visited;
  
  set visited(bool value) {
    _visited = value;
  }
}
```

   * Representation of position in the maze


A coordinate object stores a pair of integers representing `(X,Y)` coorindates in a 2-Dimensional grid. 

```dart 
//Pair object used to store x,y coordinates in the grid maze
class Coordinates {
  int _x;
  int _y;

  //constructor to initialise every instance of this object
  Coordinates(int x, int y) {
    _x = x;
    _y = y;
  }

  //getter and setter methods for the private variables
  int getX() => _x;

  int getY() => _y;

  set x(int value) {
    _x = value;
  }

  set y(int value) {
    _y = value;
  }
}
```

   * Representation of maze

The maze is a 2-dimensional grid represented using a double dimensional list. 

```java 
//2-dimensional grid of Block object
List<List<Block>> maze = [];
```

   * Constructor used to initialise variables and data structures used in maze generation algorithm

The constructor first fills the empty maze grid with new instances of `Block`. The maze can hence be visualise as such:

**insert image here**

Then it chooses a random position to start the DFS algorithm. 

```java
List<List<Block>> generate(int s) {
    //save maze size for usage outside the method
    this.size = s;
    //nested loops to initialise entire grid with a new instance of Block
    for (int i = 0; i < size; i++) {
      List<Block> init = [];
      for (int j = 0; j < size; j++) {
        init.add(Block());
      }
      maze.add(init);
    }
    //random object used to generate random numbers
    var rnd = Random();
    //randomise the starting position of the DFS algorithm
    int xStart = rnd.nextInt(size);
    int yStart = rnd.nextInt(size);
    //recursive DFS starting at the randomised coordinates
    algo(Coordinates(xStart, yStart));
    //return the generated maze
    return maze;
  }
```

   * Queue Data Structure to store visited nodes

In `Dart` the `Queue` data structure is similar to a `deque`. This enables it to function similarly to a `Stack` data structure. Since the Stack is a Last in First out data structure, a sequence is reversed when popping from the stack allowing us to backtrack through the maze. 

```java
//Queue to store previously visited since stack are unavailable in dart
Queue<Coordinates> visited = Queue<Coordinates>();
```

   * Modified Recursive Depth-First Search (DFS) Algorithm

DFS is normally used as a path finding algorithm. This has been modified to randomly traverse the maze creating a path to every single node. This can be illustrated as follows: 

**insert DFS here**

```java
//DFS algorithm to generate maze
  void algo(Coordinates coordinates) {
    //current coordinates of the algorithm
    int x = coordinates.getX();
    int y = coordinates.getY();

    //mark current node as visited
    maze[x][y].visited = true;

    //marked true if there is unvisited node
    bool unvisited = false;
    //list used to randomize which node to pick by shuffling
    List<int> randomizer = [];

    //check for adjacent visited nodes
    if (y + 1 < size) {
      if (!(maze[x][y + 1].getVisited())) {
        //up node
        unvisited = true;
        randomizer.add(1);
      }
    }
    if (x + 1 < size) {
      if (!(maze[x + 1][y].getVisited())) {
        //right node
        unvisited = true;
        randomizer.add(2);
      }
    }
    if (y - 1 >= 0) {
      if (!(maze[x][y - 1].getVisited())) {
        //down node
        unvisited = true;
        randomizer.add(3);
      }
    }
    if (x - 1 >= 0) {
      if (!(maze[x - 1][y].getVisited())) {
        //left node
        unvisited = true;
        randomizer.add(4);
      }
    }

    //check if there are unvisited nodes
    if (unvisited && randomizer.length > 0) {
      /*
      unvisited nodes exists
      +======================================================================+
      |   1. shuffle the list of unvisited nodes and pick the top element    |
      |   2. increment/decrement the coordinates accordingly                 |
      |   3. push the node to the "stack"                                    |
      |   4. run algo with the new coordinates                               |
      +======================================================================+
       */
      randomizer.shuffle(Random());
      switch (randomizer[0]) {
        case 1: //up
          maze[x][y].up = false;
          maze[x][y + 1].down = false;
          visited.add(Coordinates(x, y));
          algo(Coordinates(x, y + 1));
          break;
        case 2: //right
          maze[x][y].right = false;
          maze[x + 1][y].left = false;
          visited.add(Coordinates(x, y));
          algo(Coordinates(x + 1, y));
          break;
        case 3: //down
          maze[x][y].down = false;
          maze[x][y - 1].up = false;
          visited.add(Coordinates(x, y));
          algo(Coordinates(x, y - 1));
          break;
        case 4: //left
          maze[x][y].left = false;
          maze[x - 1][y].right = false;
          visited.add(Coordinates(x, y));
          algo(Coordinates(x - 1, y));
          break;
      }
    } else if (visited.isNotEmpty) {
      /*
      all adjacent nodes are visited already
      +=====================================================================+
      |   1. pop the previous node off the stack                            |
      |   2. run algo at the previous node                                  |
      +=====================================================================+
       */
      Coordinates prev = visited.removeLast();
      algo(prev);
    }
  }
```

2. Scoring Algorithm

The `ScoreCounter` Object contains a `Stopwatch()` to keep track of the time taken to complete the maze. When the player starts a game, `timerBegin()` is used to start the stopwatch, and `timerEnd()` is used to stop the timer when the game has ended. `calculate()` is used to generate the player score based on the time taken and the size of the maze attempted. This value is stored in `_score`. 

```dart
//ScoreCounter Object used to calculate the score of a game
class ScoreCounter {
  //variables to store the final score of the game
  int _score;
  //instance of stopwatch object to keep time
  Stopwatch _time = Stopwatch();

  //methods to control the private stopwatch object
  //starts counting
  timerBegin() {
    _time.start();
  }

  //stops counting
  timerEnd() {
    _time.stop();
  }

  //resets the counter
  timerReset() {
    _time.reset();
  }

  //mathematical scoring function
  calculate(int mazeSize) {
    double timeTaken = _time.elapsedMilliseconds.toDouble();
    double curve =
        pow(mazeSize, e) * exp(-(timeTaken/500).toDouble() / pow(mazeSize, e));
    _score = curve.truncate();
  }

  //returns the private score variable
  int get score => _score;
}
```

3. Parsing Data
   * Representation of a Score Entity containing username and player score

A `ScoreObject` represents a single score entry. It contains the username and score from a single game. This object contains methods `toJson()` and `ScoreObject.fromJson` to convert the Object to `Java Script Object Notation (JSON)`. This is essentially a formatted `String` and allows for easy storage and data transfer since `String` is a basic data type which the online and local database recognises and hence is able to process. 

```dart
//Object to store an instance of a leaderboard entry
//Object is marked as json serializable for database storage purposes
@JsonSerializable()
class ScoreObject {
  //username of the player
  final String username;
  //final score attained by the player
  final int score;

  //constructor for each instance of ScoreObject
  ScoreObject(this.username, this.score);

  //decoding json into ScoreObject
  factory ScoreObject.fromJson(Map<String, dynamic> json) =>
      _$ScoreObjectFromJson(json);

  //encoding ScoreObject to Json
  Map<String, dynamic> toJson() => _$ScoreObjectToJson(this);
}
```

  * Deserializing JSON to ScoreObject

| JSON | &rarr;&rarr;&rarr;| Object  |
| :- | :-: |:- |
| <code>{<br>"username":"Player1337",<br>"score": 31337 <br>}</code>|&rarr;&rarr;&rarr;|<code>ScoreObject{<br>String username = "Player1337";<br>int score = 31337;<br>}</code> |


```dart
ScoreObject _$ScoreObjectFromJson(Map<String, dynamic> json) {
  return ScoreObject(json['username'] as String, json['score'] as int);
}
```

  * Serializing ScoreObject to JSON

| Object | &rarr;&rarr;&rarr;| JSON  |
| :- | :-: |:- |
|<code>ScoreObject{<br>String username = "Player1337";<br>int score = 31337;<br>}</code>|&rarr;&rarr;&rarr;| <code>{<br>"username":"Player1337",<br>"score": 31337 <br>}</code>|

```java
Map<String, dynamic> _$ScoreObjectToJson(ScoreObject instance) =>
    <String, dynamic>{'username': instance.username, 'score': instance.score};
```

4. Player Navigation

When moving a player from one node to the adjacent one, first check if the move is legal (Eg. cannnot move through walls). If it is, set the player icon to true in the next cell and false in the current. Change the player coordinates and rebuild the UI. 


```dart
move(int direction) async {
    //play the movement audio
    GlobalAudioPlayer.playMoveAudio();
    /*
    +========================================================================+
    |   To move a player,                                                    |
    |     1. check if move is valid                                          |
    |     2. change the player icon to be generated at next cell             |
    |     3. increment/decrement the coordinate according to the movement    |
    |     4. rebuild the maze GUI                                            |
    +========================================================================+
     */
    switch (direction) {
      case 1:
        //move up(+y)
        if (!maze[current.getX()][current.getY()].getUp()) {
          maze[current.getX()][current.getY()].icon = false;
          maze[current.getX()][current.getY() + 1].icon = true;
          current.y = current.getY() + 1;
          setState(() {});
        }
        break;
      case 2:
        //move right(+x)
        if (!maze[current.getX()][current.getY()].getRight()) {
          maze[current.getX()][current.getY()].icon = false;
          maze[current.getX() + 1][current.getY()].icon = true;
          current.x = current.getX() + 1;
          setState(() {});
        }
        break;
      case 3:
        //move down(-y)
        if (!maze[current.getX()][current.getY()].getDown()) {
          maze[current.getX()][current.getY()].icon = false;
          maze[current.getX()][current.getY() - 1].icon = true;
          current.y = current.getY() - 1;
          setState(() {});
        }
        break;
      case 4:
        //move left(-x)
        if (!maze[current.getX()][current.getY()].getLeft()) {
          maze[current.getX()][current.getY()].icon = false;
          maze[current.getX() - 1][current.getY()].icon = true;
          current.x = current.getX() - 1;
          setState(() {});
        }
    }
  }
```

#### Flutter SDK

1. Creation of GUI components

For the purposes of this IA, not all widgets used can be covered due to the word limit. The following outline the major GUI components. More minor components such as those used to centralise or position other elements are redacted.  

   * Flutter Component Tree

In The Flutter SDK (flutter for short), there exist a library of basic GUI components, also known as Widgets. Each Widget has its own set of properties that can be configured to suit users' needs. Most Widgets have the property `child` or `children`. This property allows a Widget to contain a "child" widget or in the case of `children`, multiple "child" widgets. 

**insert diagram here**

   * Overarching Theme Manager

To facilitate easier design management, app colors can be set using a `Theme`. Widgets can access the `ThemeData` which would affect the appearance of the widget. A global theme object allows for consistency in design throughout the app. 

```dart
ThemeData(
  brightness: Brightness.dark,
  primaryColor: Colors.white,
  buttonColor: Color(0x00FFFFFF),
  primaryColorDark: Color(0xFF000A12),
  accentColor: Color(0xFF003C8F),
  canvasColor: Color(0xFF263238),
  accentTextTheme: TextTheme(
      body2: TextStyle(
          color: Colors.black, fontWeight: FontWeight.bold)),
  textTheme: TextTheme(
      headline: TextStyle(
          fontSize: 50,
          color: Colors.white,
          fontWeight: FontWeight.bold),
      title: TextStyle(fontSize: 25, color: Colors.black),
      caption: TextStyle(fontSize: 20, color: Colors.white),
      subhead: TextStyle(
          fontSize: 20,
          color: Colors.white,
          fontWeight: FontWeight.bold),
      body1: TextStyle(fontSize: 17, color: Colors.white),
      body2: TextStyle(fontSize: 15, color: Colors.white),
      button: TextStyle(fontSize: 20, color: Colors.white, shadows: [
        Shadow(
            color: Color(0xFF000A12),
            offset: Offset(5, 5),
            blurRadius: 10)
      ])),
  buttonTheme: ButtonThemeData(
      height: 50,
      minWidth: 200,
      padding: EdgeInsets.all(10),
      buttonColor: Colors.transparent)
)
```
   * Text Widget

A Text Widget displays text. It has multiple properties such as `fontSize`, `color` and `textAlign` which can be set using ThemeData. The following code snippet is an example of a Text Widget displaying the String "PLAY".

```dart
Text('PLAY', style: Theme.of(context).textTheme.button)
```

   * Icon Widget

The Icon Widget displays an Icon. The exmaple below results in the following: **insert gamepad icon**

```dart
Icon(MdiIcons.gamepad)
```

   * Column/Row Widget

A `column` can contain multiple `children`. This is often used as one of the larger parent widgets. This allows us to display multiple items vertically. We can set the column alignment using `mainAxisAlignment`. A `row` is essentially the same as `column`, but built horizontally. The code snippet shows an empty column.

```dart
Column(
  //the widget expands from the center outwards instead of the default top down when more children are added
  mainAxisAlignment: MainAxisAlignment.center,
  //array of children contained by the parent column
  children: <Widget> []
)
```

   * Button Widget
   
The button widget by default is blank. The button widget can however contain a child element. This is often used to configure the appearance of the button. For example, a button with Text Widget as a child element would display a text. Other properties such as `padding` and `shape` of the button can also be configured to change the appearance of the button. The onPressed property of the button would be explored in detail later. The following example of a button displays:
**insert image of play button**

```dart
MaterialButton(
  //set the minimum width to be half of the device screen
  minWidth: dev.screenWidth * 0.5,
  //spaces GUI elements from each other
  padding: EdgeInsets.all(10),
  //making the corners of the button rounded
  shape: RoundedRectangleBorder(
      borderRadius: BorderRadius.circular(13)),
  child: Row(children: <Widget> [
    Container(width: dev.screenWidth * 0.2),
    Icon(MdiIcons.gamepad),
    Container(width: dev.screenWidth * 0.02),
    Text('PLAY', style: Theme.of(context).textTheme.button)
  ]),
  onPressed(): ...
)
```

   * TextField Widget

A `TextField` is an input field for the user. It accepts a `String` input from the user. A `TextField` cannot contain a child but intead has the `decoration` property which is often used to set hints. The code snippet would display, 
**insert textfield widget**

```dart
TextField(
  decoration: InputDecoration(hintText: "Enter Username"),
  controller: textController,
  maxLength: 20,
  minLines: 1,
)
```

   * Slider Widget

A `Slider` is yet another widget which helps take input from the user. The `value` property refers to the current value of the slider. The `min` and `max` values can be set to outline the lower and upper bound of the slider. The onChanged fucntion will be discussed later in detail. The slider created by the code below looks like this,
**insert slider**
   
```dart
Slider(
  //maze size is a global variable to be set by the user using the slider
  value: mazeSize.toDouble(),
  min: 2,
  max: 30,
  onChanged: ...
)
```

   * Leaderboard Interface
   
```dart

```

   * Color Picker Interface
   
```dart

```

   * Maze Interface
   
```dart

```

2. Handling User Interaction with GUI elements


   * Button OnPressed Function
   
```dart

```

   * Slider OnChanged Function
   
```dart

```

   * Accessing Textfield Input
   
```dart

```

3. Lcoal Storage of User Data

   * Local Leaderboard Storage
   
```dart

```

   * Game Settings Storage
   
```dart

```

   * Initialisation of Previous Settings on App Start

```dart
```

4. Animations

   * Splash Loading Animation
   
```dart

```

   * Home Page Animation
   
```dart

```

5. Game Audio

   * Column Widget
   
```dart

```

6. Managing Application Lifecycle

   * Outline of Flutter Application Lifecycle
   
```dart

```

   * Initialisation State
   
```dart

```

   * Change of Lifecycle State
   
```dart

```

   * Dispose State
   
```dart

```


#### Firebase

1. NoSQL database storage system

The database has multiple `collections`, each for a private leaderboard. The leaderboard with ID: “testboard” was created for the documentation and testing purposes of this IA. As shown from the image below,

**insert image of firebase console here**


2. Asynchronous Network Communications

   * Saving Data 
   
```dart

```


   * Creation of new Document
   
```dart

```


   * Accessing Stored Data
   
```dart

```
```json
{ 
   "Leaderboard":{ 
      "Random_Board_ID_1":[ 

      ],
      "Random_Board_ID_2":[ 

      ],
      "Random_Board_ID_3":[ 
         { 
            "username":"exampleUsername1",
            "score":1337
         },
         { 
            "username":"exampleUsername2",
            "score":1337
         },
         { 
            "username":"exampleUsername3",
            "score":1337
         }
      ]
   }
}
```




